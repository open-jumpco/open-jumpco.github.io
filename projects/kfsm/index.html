<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>KFSM - Kotlin Finite-state machine</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link href="prism.css" rel="stylesheet" />
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>KFSM - Kotlin Finite-state machine</h1>
<div class="details">
<span id="revnumber">version 1.0.2</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#links">Links</a>
<ul class="sectlevel2">
<li><a href="#api-docs">API Docs</a></li>
<li><a href="#source">Source</a></li>
</ul>
</li>
<li><a href="#features">Features</a></li>
<li><a href="#tutorial">Tutorial</a>
<ul class="sectlevel2">
<li><a href="#simple-turnstile-example">Simple turnstile example</a>
<ul class="sectlevel3">
<li><a href="#state-diagram">State Diagram</a></li>
<li><a href="#state-table">State Table</a></li>
<li><a href="#context-class">Context class</a></li>
<li><a href="#enums-for-states-and-events">Enums for States and Events</a></li>
<li><a href="#packaged-definition-and-execution">Packaged definition and execution</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
</li>
<li><a href="#advanced-features">Advanced Features</a>
<ul class="sectlevel3">
<li><a href="#state-table-2">State Table</a></li>
<li><a href="#context-class-2">Context class</a></li>
<li><a href="#states-and-events">States and Events</a></li>
<li><a href="#state-machine-definition-packaged">State machine definition packaged</a></li>
<li><a href="#test">Test</a></li>
<li><a href="#output">Output</a></li>
</ul>
</li>
<li><a href="#secure-turnstile-example">Secure Turnstile Example</a>
<ul class="sectlevel3">
<li><a href="#state-table-3">State Table</a></li>
<li><a href="#context-class-3">Context class</a></li>
<li><a href="#states-and-events-2">States and Events</a></li>
<li><a href="#state-machine-definition-packaged-2">State machine definition packaged</a></li>
<li><a href="#test-2">Test</a></li>
</ul>
</li>
<li><a href="#packet-reader-example">Packet Reader Example</a>
<ul class="sectlevel3">
<li><a href="#context-classes">Context Classes</a></li>
<li><a href="#states-and-events-3">States and Events</a></li>
<li><a href="#packaged-fsm">Packaged FSM</a></li>
<li><a href="#tests">Tests</a></li>
</ul>
</li>
<li><a href="#immutable-context-example">Immutable Context Example</a>
<ul class="sectlevel3">
<li><a href="#immutable-context">Immutable Context</a></li>
<li><a href="#definition">Definition</a></li>
<li><a href="#usage-2">Usage</a></li>
</ul>
</li>
<li><a href="#further-thoughts">Further thoughts</a></li>
</ul>
</li>
<li><a href="#getting-started">Getting Started</a>
<ul class="sectlevel2">
<li><a href="#repository">Repository</a></li>
<li><a href="#dependencies">Dependencies</a>
<ul class="sectlevel3">
<li><a href="#kotlinjvm-projects">Kotlin/JVM Projects</a></li>
<li><a href="#kotlinjs-projects">KotlinJS Projects</a></li>
<li><a href="#kotlinnative-projects-using-wasm">Kotlin/Native Projects using WASM</a></li>
<li><a href="#kotlinnative-projects-using-linuxx64">Kotlin/Native Projects using LinuxX64</a></li>
<li><a href="#kotlinnative-projects-using-mingw64">Kotlin/Native Projects using MinGW64</a></li>
<li><a href="#kotlinnative-projects-using-macos">Kotlin/Native Projects using macOS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#operation">Operation</a>
<ul class="sectlevel2">
<li><a href="#send-event">Send Event</a></li>
<li><a href="#named-maps-and-push-pop-transitions">Named Maps and Push / Pop Transitions</a></li>
<li><a href="#life-cycle">Life-cycle</a></li>
</ul>
</li>
<li><a href="#dsl">DSL</a>
<ul class="sectlevel2">
<li><a href="#statemachine"><code>stateMachine</code></a></li>
<li><a href="#functionalstatemachine"><code>functionalStateMachine</code></a></li>
<li><a href="#asyncstatemachine"><code>asyncStateMachine</code></a></li>
<li><a href="#asyncfunctionalstatemachine"><code>asyncFunctionalStateMachine</code></a></li>
<li><a href="#default"><code>default</code></a>
<ul class="sectlevel3">
<li><a href="#action"><code>action</code></a></li>
<li><a href="#onentry"><code>onEntry</code></a></li>
<li><a href="#onexit"><code>onExit</code></a></li>
<li><a href="#onevent"><code>onEvent</code></a></li>
</ul>
</li>
<li><a href="#initialstate"><code>initialState</code></a></li>
<li><a href="#initialstates"><code>initialStates</code></a></li>
<li><a href="#whenstate"><code>whenState</code></a>
<ul class="sectlevel3">
<li><a href="#default-2"><code>default</code></a></li>
<li><a href="#onentry-2"><code>onEntry</code></a></li>
<li><a href="#onexit-2"><code>onExit</code></a></li>
<li><a href="#automatic"><code>automatic</code></a></li>
<li><a href="#automaticpop"><code>automaticPop</code></a></li>
<li><a href="#automaticpush"><code>automaticPush</code></a></li>
<li><a href="#onevent-2"><code>onEvent</code></a></li>
<li><a href="#oneventpush"><code>onEventPush</code></a></li>
<li><a href="#oneventpop"><code>onEventPop</code></a></li>
<li><a href="#timeout"><code>timeout</code></a></li>
<li><a href="#timeoutpop"><code>timeoutPop</code></a></li>
<li><a href="#timeoutpush"><code>timeoutPush</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Having used various incarnations of <a href="http://smc.sourceforge.net/">SMC</a> over the years we decided to try it again and
discovered it didn&#8217;t have specific support for Kotlin. Instead of creating a generator for Kotlin we decided to attempt
a Kotlin DSL along with a simple implementation.</p>
</div>
<div class="paragraph">
<p>To learn more about Finite State Machines visit:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Finite-state_machine">Wikipedia - Finite-state machine</a></p>
</li>
<li>
<p><a href="https://brilliant.org/wiki/finite-state-machines/">Brilliant - Finite State Machines</a></p>
</li>
<li>
<p><a href="http://smc.sourceforge.net/slides/SMC_Tutorial.pdf">SMC Tutorial</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <a href="#tutorial">Tutorial</a> provides examples of how to compose a DSL and FSM.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="links">Links</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="api-docs"><a href="javadoc/kfsm/index.html">API Docs</a></h3>

</div>
<div class="sect2">
<h3 id="source"><a href="https://github.com/open-jumpco/kfsm">Source</a></h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="features">Features</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This Finite state machine implementation has the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Event driven state machine.</p>
</li>
<li>
<p>External and internal transitions</p>
</li>
<li>
<p>State entry and exit actions.</p>
</li>
<li>
<p>Default state actions.</p>
</li>
<li>
<p>Default entry and exit actions.</p>
</li>
<li>
<p>Determine allowed events for current or given state.</p>
</li>
<li>
<p>Multiple state maps with push / pop transitions</p>
</li>
<li>
<p>Automatic transitions</p>
</li>
<li>
<p>Externalisation of state.</p>
</li>
<li>
<p>Simple Visualization.</p>
</li>
<li>
<p>Detailed Visualization.</p>
</li>
<li>
<p>Visualization Gradle Plugin</p>
</li>
<li>
<p>Coroutines</p>
</li>
<li>
<p>Timeout Transitions</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tutorial">Tutorial</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="simple-turnstile-example">Simple turnstile example</h3>
<div class="paragraph">
<p>Assume we and to manage the state on a simple lock.
We want to ensure that the <code>lock()</code> function is only called when the lock is not locked and we want <code>unlock()</code> to be called when locked.</p>
</div>
<div class="paragraph">
<p>Then we use the DSL to declare a definition of a statemachine matching the diagram:</p>
</div>
<div class="sect3">
<h4 id="state-diagram">State Diagram</h4>
<div class="imageblock">
<div class="content">
<img src="turnstile-fsm.png" alt="LockStateDiagram">
</div>
</div>
</div>
<div class="sect3">
<h4 id="state-table">State Table</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Start State</th>
<th class="tableblock halign-left valign-top">Event</th>
<th class="tableblock halign-left valign-top">End State</th>
<th class="tableblock halign-left valign-top">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PASS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">alarm</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">COIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNLOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unlock</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNLOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PASS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lock</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNLOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">COIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNLOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">returnCoin</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="context-class">Context class</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Turnstile(locked: Boolean = true) {
    var locked: Boolean = locked
        private set

    fun unlock() {
        require(locked) { "Cannot unlock when not locked" }
        println("Unlock")
        locked = false
    }

    fun lock() {
        require(!locked) { "Cannot lock when locked" }
        println("Lock")
        locked = true
    }

    fun alarm() {
        println("Alarm")
    }

    fun returnCoin() {
        println("Return Coin")
    }

    override fun toString(): String {
        return "Turnstile(locked=$locked)"
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enums-for-states-and-events">Enums for States and Events</h4>
<div class="paragraph">
<p>We declare 2 enums, one for the possible states and one for the possible events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">enum class PayingTurnstileStates {
    LOCKED,
    COINS,
    UNLOCKED
}

/**
 * @suppress
 */
enum class PayingTurnstileEvents {
    COIN,
    PASS
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="packaged-definition-and-execution">Packaged definition and execution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class PayingTurnstileFSM(
    turnstile: PayingTurnstile,
    initialState: ExternalState&lt;PayingTurnstileStates&gt;? = null
) {
    val fsm = if (initialState != null) {
        definition.create(turnstile, initialState)
    } else {
        definition.create(
            turnstile,
            PayingTurnstileStates.LOCKED
        )
    }

    fun coin(value: Int) {
        println("sendEvent:COIN:$value")
        fsm.sendEvent(PayingTurnstileEvents.COIN, value)
    }

    fun pass() {
        println("sendEvent:PASS")
        fsm.sendEvent(PayingTurnstileEvents.PASS)
    }

    fun allowedEvents() = fsm.allowed().map { it.name.toLowerCase() }.toSet()
    fun externalState() = fsm.externalState()

    companion object {
        val definition = stateMachine(
            setOf(PayingTurnstileStates.LOCKED, PayingTurnstileStates.UNLOCKED),
            PayingTurnstileEvents.values().toSet(),
            PayingTurnstile::class,
            Int::class
        ) {
            defaultInitialState = PayingTurnstileStates.LOCKED
            default {
                onEntry { _, targetState, arg -&gt;
                    if (arg != null) {
                        println("entering:$targetState ($arg) for $this")
                    } else {
                        println("entering:$targetState for $this")
                    }
                }
                action { state, event, arg -&gt;
                    if (arg != null) {
                        println("Default action for state($state) -&gt; on($event, $arg) for $this")
                    } else {
                        println("Default action for state($state) -&gt; on($event) for $this")
                    }
                    alarm()
                }
                onExit { startState, _, arg -&gt;
                    if (arg != null) {
                        println("exiting:$startState ($arg) for $this")
                    } else {
                        println("exiting:$startState for $this")
                    }
                }
            }
            stateMap("coins", setOf(PayingTurnstileStates.COINS)) {
                whenState(PayingTurnstileStates.COINS) {
                    automaticPop(PayingTurnstileStates.UNLOCKED, guard = { coins &gt; requiredCoins }) {
                        println("automaticPop:returnCoin")
                        returnCoin(coins - requiredCoins)
                        unlock()
                        reset()
                    }
                    automaticPop(PayingTurnstileStates.UNLOCKED, guard = { coins == requiredCoins }) {
                        println("automaticPop")
                        unlock()
                        reset()
                    }
                    onEvent(PayingTurnstileEvents.COIN) { value -&gt;
                        require(value != null) { "argument required for COIN" }
                        coin(value)
                        println("Coins=$coins")
                        if (coins &lt; requiredCoins) {
                            println("Please add ${requiredCoins - coins}")
                        }
                    }
                }
            }
            whenState(PayingTurnstileStates.LOCKED) {
                // The coin brings amount to exact amount
                onEventPush(PayingTurnstileEvents.COIN, "coins", PayingTurnstileStates.COINS) { value -&gt;
                    require(value != null) { "argument required for COIN" }
                    coin(value)
                    unlock()
                    reset()
                }
                // The coins add up to more than required
                onEventPush(PayingTurnstileEvents.COIN, "coins", PayingTurnstileStates.COINS,
                    guard = { value -&gt;
                        require(value != null) { "argument required for COIN" }
                        value + coins &lt; requiredCoins
                    }) { value -&gt;
                    require(value != null) { "argument required for COIN" }
                    println("PUSH TRANSITION")
                    coin(value)
                    println("Coins=$coins, Please add ${requiredCoins - coins}")
                }
            }
            whenState(PayingTurnstileStates.UNLOCKED) {
                onEvent(PayingTurnstileEvents.COIN) { value -&gt;
                    require(value != null) { "argument required for COIN" }
                    returnCoin(coin(value))
                }
                onEvent(PayingTurnstileEvents.PASS to PayingTurnstileStates.LOCKED) {
                    lock()
                }
            }
        }.build()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="usage">Usage</h4>
<div class="paragraph">
<p>Then we instantiate the FSM and provide a context to operate on:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val turnstile = Turnstile()
val fsm = TurnstileFSM(turnstile)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have a context that is independent of the FSM.</p>
</div>
<div class="paragraph">
<p>Sending events may invoke actions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// State state is LOCKED
fsm.coin()
// Expect unlock action end state is UNLOCKED
fsm.pass()
// Expect lock() action and end state is LOCKED
fsm.pass()
// Expect alarm() action and end state is LOCKED
fsm.coin()
// Expect unlock() and end state is UNLOCKED
fsm.coin()
// Expect returnCoin() and end state is UNLOCKED</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/open-jumpco/kfsm-samples">Samples</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="statemachine-model.png" alt="StateMachineModel">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-features">Advanced Features</h3>
<div class="paragraph">
<p>We can add arguments to events and use named state maps with push / pop and automatic transitions.</p>
</div>
<div class="paragraph">
<p>Arguments are sent as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fsm.sendEvent(EVENT1, arg1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The argument is references in the action as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">onEvent(EVENT1) { args -&gt;
    val value = args[0] as Int
    // use value
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we update the turnstile to include the value of the coin in the coin event we could implement the following:
A named state where decisions regarding coins are made.
We push to <code>coins</code> with COINS state and then the automatic states will be triggered if the guards are met.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="paying-turnstile-fsm.png" alt="Paying Turnstile">
</div>
</div>
<div class="sect3">
<h4 id="state-table-2">State Table</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Start State</th>
<th class="tableblock halign-left valign-top">Event</th>
<th class="tableblock halign-left valign-top">Guard Expression</th>
<th class="tableblock halign-left valign-top">End State</th>
<th class="tableblock halign-left valign-top">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PASS</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">alarm</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">COIN</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">COINS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">coin(value)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNLOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PASS</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lock</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COINS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">COIN</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">COINS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">coin(value)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COINS</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">coins == requiredCoins</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNLOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unlock</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COINS</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">coins &gt; requiredCoins</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNLOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">returnCoin(coins-requiredCoins), unlock</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When event is empty it is an automatic transition.
We will further place COINS state in a named state map to illustrate how these can be composes to isolate or group behaviour.</p>
</div>
</div>
<div class="sect3">
<h4 id="context-class-2">Context class</h4>
<div class="paragraph">
<p>The context class doesn&#8217;t make decisions.
The context class stores values and will update value in very specific ways.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class PayingTurnstile(
    val requiredCoins: Int,
    locked: Boolean = true,
    coins: Int = 0
) {
    var coins: Int = coins
        private set
    var locked: Boolean = locked
        private set

    fun unlock() {
        require(locked) { "Cannot unlock when not locked" }
        require(coins &gt;= requiredCoins) { "Not enough coins. ${requiredCoins - coins} required" }
        println("Unlock")
        locked = false
    }

    fun lock() {
        require(!locked) { "Cannot lock when locked" }
        require(coins == 0) { "Coins $coins must be returned" }
        println("Lock")
        locked = true
    }

    fun alarm() {
        println("Alarm")
    }

    fun coin(value: Int): Int {
        coins += value
        println("Coin received=$value, Total=$coins")
        return coins
    }

    fun returnCoin(returnCoins: Int) {
        println("Return Coin:$returnCoins")
        coins -= returnCoins
    }

    fun reset() {
        coins = 0
        println("Reset coins=$coins")
    }

    override fun toString(): String {
        return "Turnstile(locked=$locked,coins=$coins)"
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="states-and-events">States and Events</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">enum class PayingTurnstileStates {
    LOCKED,
    COINS,
    UNLOCKED
}

/**
 * @suppress
 */
enum class PayingTurnstileEvents {
    COIN,
    PASS
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We add a stateMap named <code>coins</code> with the state <code>COINS</code>.
The statemap  will be entered when there are coins.
The automatic transitions will be triggered based on the guard expressions.</p>
</div>
</div>
<div class="sect3">
<h4 id="state-machine-definition-packaged">State machine definition packaged</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class PayingTurnstileFSM(
    turnstile: PayingTurnstile,
    initialState: ExternalState&lt;PayingTurnstileStates&gt;? = null
) {
    val fsm = if (initialState != null) {
        definition.create(turnstile, initialState)
    } else {
        definition.create(
            turnstile,
            PayingTurnstileStates.LOCKED
        )
    }

    fun coin(value: Int) {
        println("sendEvent:COIN:$value")
        fsm.sendEvent(PayingTurnstileEvents.COIN, value)
    }

    fun pass() {
        println("sendEvent:PASS")
        fsm.sendEvent(PayingTurnstileEvents.PASS)
    }

    fun allowedEvents() = fsm.allowed().map { it.name.toLowerCase() }.toSet()
    fun externalState() = fsm.externalState()

    companion object {
        val definition = stateMachine(
            setOf(PayingTurnstileStates.LOCKED, PayingTurnstileStates.UNLOCKED),
            PayingTurnstileEvents.values().toSet(),
            PayingTurnstile::class,
            Int::class
        ) {
            defaultInitialState = PayingTurnstileStates.LOCKED
            default {
                onEntry { _, targetState, arg -&gt;
                    if (arg != null) {
                        println("entering:$targetState ($arg) for $this")
                    } else {
                        println("entering:$targetState for $this")
                    }
                }
                action { state, event, arg -&gt;
                    if (arg != null) {
                        println("Default action for state($state) -&gt; on($event, $arg) for $this")
                    } else {
                        println("Default action for state($state) -&gt; on($event) for $this")
                    }
                    alarm()
                }
                onExit { startState, _, arg -&gt;
                    if (arg != null) {
                        println("exiting:$startState ($arg) for $this")
                    } else {
                        println("exiting:$startState for $this")
                    }
                }
            }
            stateMap("coins", setOf(PayingTurnstileStates.COINS)) {
                whenState(PayingTurnstileStates.COINS) {
                    automaticPop(PayingTurnstileStates.UNLOCKED, guard = { coins &gt; requiredCoins }) {
                        println("automaticPop:returnCoin")
                        returnCoin(coins - requiredCoins)
                        unlock()
                        reset()
                    }
                    automaticPop(PayingTurnstileStates.UNLOCKED, guard = { coins == requiredCoins }) {
                        println("automaticPop")
                        unlock()
                        reset()
                    }
                    onEvent(PayingTurnstileEvents.COIN) { value -&gt;
                        require(value != null) { "argument required for COIN" }
                        coin(value)
                        println("Coins=$coins")
                        if (coins &lt; requiredCoins) {
                            println("Please add ${requiredCoins - coins}")
                        }
                    }
                }
            }
            whenState(PayingTurnstileStates.LOCKED) {
                // The coin brings amount to exact amount
                onEventPush(PayingTurnstileEvents.COIN, "coins", PayingTurnstileStates.COINS) { value -&gt;
                    require(value != null) { "argument required for COIN" }
                    coin(value)
                    unlock()
                    reset()
                }
                // The coins add up to more than required
                onEventPush(PayingTurnstileEvents.COIN, "coins", PayingTurnstileStates.COINS,
                    guard = { value -&gt;
                        require(value != null) { "argument required for COIN" }
                        value + coins &lt; requiredCoins
                    }) { value -&gt;
                    require(value != null) { "argument required for COIN" }
                    println("PUSH TRANSITION")
                    coin(value)
                    println("Coins=$coins, Please add ${requiredCoins - coins}")
                }
            }
            whenState(PayingTurnstileStates.UNLOCKED) {
                onEvent(PayingTurnstileEvents.COIN) { value -&gt;
                    require(value != null) { "argument required for COIN" }
                    returnCoin(coin(value))
                }
                onEvent(PayingTurnstileEvents.PASS to PayingTurnstileStates.LOCKED) {
                    lock()
                }
            }
        }.build()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test">Test</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">        val turnstile = PayingTurnstile(50)
        val fsm = PayingTurnstileFSM(turnstile)
        assertTrue(turnstile.locked)
        println("External:${fsm.externalState()}")
        println("--coin1")
        fsm.coin(10)
        assertTrue(turnstile.locked)
        assertTrue(turnstile.coins == 10)
        assertTrue(
            fsm.fsm.currentStateMap.name != null &amp;&amp; "coins" == fsm.fsm.currentStateMap.name,
            "Expected coins map"
        )
        println("--coin2")
        println("External:${fsm.externalState()}")
        fsm.coin(60)
        assertTrue(turnstile.coins == 0)
        assertTrue(!turnstile.locked)
        println("External:${fsm.externalState()}")
        assertTrue(fsm.fsm.currentStateMap.name == null, "Expected default map not ${fsm.fsm.currentStateMap.name}")
        println("--pass1")
        fsm.pass()
        assertTrue(turnstile.locked)
        println("--pass2")
        fsm.pass()
        println("--pass3")
        fsm.pass()
        println("--coin3")
        fsm.coin(40)
        assertTrue(turnstile.coins == 40)
        println("--coin4")
        fsm.coin(10)
        assertTrue(turnstile.coins == 0)
        assertTrue(!turnstile.locked)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="output">Output</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>--coin1
sendEvent:COIN:10
entering:LOCKED ([10]) for Turnstile(locked=true,coins=0)
PUSH TRANSITION
Coin received=10, Total=10
Coins=10, Please add 40
--coin2
sendEvent:COIN:60
Coin received=60, Total=70
Return Coin:20
Unlock
Reset coins=0
entering:UNLOCKED ([60]) for Turnstile(locked=false,coins=0)
--pass1
sendEvent:PASS
exiting:UNLOCKED for Turnstile(locked=false,coins=0)
Lock
entering:LOCKED for Turnstile(locked=true,coins=0)
--pass2
sendEvent:PASS
Default action for state(LOCKED) -&gt; on(PASS) for Turnstile(locked=true,coins=0)
Alarm
--pass3
sendEvent:PASS
Default action for state(LOCKED) -&gt; on(PASS) for Turnstile(locked=true,coins=0)
Alarm
--coin3
sendEvent:COIN:40
entering:LOCKED ([40]) for Turnstile(locked=true,coins=0)
PUSH TRANSITION
Coin received=40, Total=40
Coins=40, Please add 10
--coin4
sendEvent:COIN:10
Coin received=10, Total=50
Unlock
Reset coins=0
entering:UNLOCKED ([10]) for Turnstile(locked=false,coins=0)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="secure-turnstile-example">Secure Turnstile Example</h3>
<div class="paragraph">
<p>Unless you grew up in a city with a subway you may not be familiar with a turnstile accepting counts.
You may be familiar with turnstile that responds to RFID or NFC cards.</p>
</div>
<div class="paragraph">
<p>We would add a complexity that allows for an override card to allow cards to pass even if they are invalid.</p>
</div>
<div class="paragraph">
<p>We will use guard expressions to identify the override card and the validity of the card.
When the override card is tapped a 2nd time it will cancel the override or lock the turnstile depending on the state.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="secure-turnstile-fsm.png" alt="Secure Turnstile FSM">
</div>
</div>
<div class="sect3">
<h4 id="state-table-3">State Table</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Start State</th>
<th class="tableblock halign-left valign-top">Event</th>
<th class="tableblock halign-left valign-top">Guard Expression</th>
<th class="tableblock halign-left valign-top">End State</th>
<th class="tableblock halign-left valign-top">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CARD(id)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">isOverrideCard(id) and overrideActive</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cancelOverride()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CARD(id)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">isOverrideCard(id)</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">activateOverride()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CARD(id)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">overrideActive or isValidCard(id)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNLOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unlock()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CARD(id)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">not isValidVard(id)</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">invalidCard()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNLOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PASS</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOCKED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lock()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>default</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">buzzer()</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="context-class-3">Context class</h4>
<div class="paragraph">
<p>The context class doesn&#8217;t make decisions about the behaviour of the turnstile.
The context will provide information about the state of turnstile and validity of cards
The context class stores values and will update value in very specific ways.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class SecureTurnstile {
    var locked: Boolean = true
        private set
    var overrideActive: Boolean = false
        private set

    fun activateOverride() {
        overrideActive = true
        println("override activated")
    }

    fun cancelOverride() {
        overrideActive = false
        println("override canceled")
    }

    fun lock() {
        println("lock")
        locked = true
        overrideActive = false
    }

    fun unlock() {
        println("unlock")
        locked = false
        overrideActive = false
    }

    fun buzzer() {
        println("BUZZER")
    }

    fun invalidCard(cardId: Int) {
        println("Invalid card $cardId")
    }

    fun isOverrideCard(cardId: Int): Boolean {
        return cardId == 42
    }

    fun isValidCard(cardId: Int): Boolean {
        return cardId % 2 == 1
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="states-and-events-2">States and Events</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">enum class SecureTurnstileEvents {
    CARD,
    PASS
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="state-machine-definition-packaged-2">State machine definition packaged</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class SecureTurnstileFSM(private val secureTurnstile: SecureTurnstile) {
    companion object {
        val definition = stateMachine(
            SecureTurnstileStates.values().toSet(),
            SecureTurnstileEvents.values().toSet(),
            SecureTurnstile::class,
            Int::class
        ) {
            defaultInitialState = SecureTurnstileStates.LOCKED
            initialState { if (locked) SecureTurnstileStates.LOCKED else SecureTurnstileStates.UNLOCKED }
            default {
                action { _, _, _ -&gt;
                    buzzer()
                }
            }
            whenState(SecureTurnstileStates.LOCKED) {
                onEvent(SecureTurnstileEvents.CARD, guard = { cardId -&gt; requireNotNull(cardId)
                    isOverrideCard(cardId) &amp;&amp; overrideActive
                }) {
                    cancelOverride()
                }
                onEvent(SecureTurnstileEvents.CARD, guard = { cardId -&gt; requireNotNull(cardId)
                    isOverrideCard(cardId)
                }) {
                    activateOverride()
                }
                onEvent(SecureTurnstileEvents.CARD to SecureTurnstileStates.UNLOCKED,
                    guard = { cardId -&gt; requireNotNull(cardId)
                        overrideActive || isValidCard(cardId)
                    }) {
                    unlock()
                }
                onEvent(SecureTurnstileEvents.CARD, guard = { cardId -&gt;
                    requireNotNull(cardId) { "cardId is required" }
                    !isValidCard(cardId)
                }) { cardId -&gt; requireNotNull(cardId)
                    invalidCard(cardId)
                }
            }
            whenState(SecureTurnstileStates.UNLOCKED) {
                onEvent(SecureTurnstileEvents.CARD to SecureTurnstileStates.LOCKED, guard = { cardId -&gt; requireNotNull(cardId)
                    isOverrideCard(cardId)
                }) {
                    lock()
                }
                onEvent(SecureTurnstileEvents.PASS to SecureTurnstileStates.LOCKED) {
                    lock()
                }
            }
        }.build()
    }

    private val fsm = definition.create(secureTurnstile)
    fun card(cardId: Int) = fsm.sendEvent(SecureTurnstileEvents.CARD, cardId)
    fun pass() = fsm.sendEvent(SecureTurnstileEvents.PASS)
    fun allowEvent(): Set&lt;String&gt; = fsm.allowed().map { it.name.toLowerCase() }.toSet()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-2">Test</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">        val turnstile = PayingTurnstile(50)
        val fsm = PayingTurnstileFSM(turnstile)
        assertTrue(turnstile.locked)
        println("External:${fsm.externalState()}")
        println("--coin1")
        fsm.coin(10)
        assertTrue(turnstile.locked)
        assertTrue(turnstile.coins == 10)
        assertTrue(
            fsm.fsm.currentStateMap.name != null &amp;&amp; "coins" == fsm.fsm.currentStateMap.name,
            "Expected coins map"
        )
        println("--coin2")
        println("External:${fsm.externalState()}")
        fsm.coin(60)
        assertTrue(turnstile.coins == 0)
        assertTrue(!turnstile.locked)
        println("External:${fsm.externalState()}")
        assertTrue(fsm.fsm.currentStateMap.name == null, "Expected default map not ${fsm.fsm.currentStateMap.name}")
        println("--pass1")
        fsm.pass()
        assertTrue(turnstile.locked)
        println("--pass2")
        fsm.pass()
        println("--pass3")
        fsm.pass()
        println("--coin3")
        fsm.coin(40)
        assertTrue(turnstile.coins == 40)
        println("--coin4")
        fsm.coin(10)
        assertTrue(turnstile.coins == 0)
        assertTrue(!turnstile.locked)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="packet-reader-example">Packet Reader Example</h3>
<div class="imageblock">
<div class="content">
<img src="packet-reader-fsm.png" alt="packet reader fsm">
</div>
</div>
<div class="paragraph">
<p>In real terms the above example combines multiple transitions into one for brevity.
It is better when all control characters are one type of event with guard expressions.
All events have a parameter which is the byte received and the event type is either BYTE, CTRL or ESC where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ESC is 0x1B</p>
</li>
<li>
<p>CTRL is for SOH,STX,ETX,EOT, ACK, NAK</p>
</li>
<li>
<p>BYTE all other characters</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="packet-reader-fsm-guard.png" alt="packet reader fsm guard">
</div>
</div>
<div class="sect3">
<h4 id="context-classes">Context Classes</h4>
<div class="paragraph">
<p>The current checksum is a trivial implementation for the demonstration where the checksum has a character that matches the first character of each field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Block {
    val byteArrayOutputStream = ByteArrayOutputStream(32)
    fun addByte(byte: Int) {
        byteArrayOutputStream.write(byte)
    }
}

interface ProtocolHandler {
    fun sendNACK()
    fun sendACK()
}

interface PacketHandler : ProtocolHandler {
    val checksumValid: Boolean
    fun print()
    fun addField()
    fun endField()
    fun addByte(byte: Int)
    fun addChecksum(byte: Int)
    fun checksum()
}

class ProtocolSender : ProtocolHandler {
    override fun sendNACK() {
        println("NACK")
    }

    override fun sendACK() {
        println("ACK")
    }
}

class Packet(private val protocolHandler: ProtocolHandler) : PacketHandler,
    ProtocolHandler by protocolHandler {
    val fields = mutableListOf&lt;ByteArray&gt;()
    private var currentField: Block? = null
    private var _checksumValid: Boolean = false

    override val checksumValid: Boolean
        get() = _checksumValid
    private val checkSum = Block()

    override fun print() {
        println("Checksum:$checksumValid:Fields:${fields.size}")
        fields.forEachIndexed { index, bytes -&gt;
            print("FLD:$index:")
            bytes.forEach { byte -&gt;
                val hex = byte.toString(16).padStart(2, '0')
                print(" $hex")
            }
            println()
        }
        println()
    }

    override fun addField() {
        currentField = Block()
    }

    override fun endField() {
        val field = currentField
        require(field != null) { "expected currentField to have a value" }
        fields.add(field.byteArrayOutputStream.toByteArray())
        currentField = null
    }

    override fun addByte(byte: Int) {
        val field = currentField
        require(field != null) { "expected currentField to have a value" }
        field.addByte(byte)
    }

    override fun addChecksum(byte: Int) {
        checkSum.addByte(byte)
    }

    override fun checksum() {
        require(checkSum.byteArrayOutputStream.size() &gt; 0)
        val checksumBytes = checkSum.byteArrayOutputStream.toByteArray()
        _checksumValid = if (checksumBytes.size == fields.size) {
            checksumBytes.mapIndexed { index, cs -&gt;
                cs == fields[index][0]
            }.reduce { a, b -&gt; a &amp;&amp; b }
        } else {
            false
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="states-and-events-3">States and Events</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class CharacterConstants {
    companion object {
        const val SOH = 0x01
        const val STX = 0x02
        const val ETX = 0x03
        const val EOT = 0x04
        const val ACK = 0x06
        const val NAK = 0x15
        const val ESC = 0x1b
    }
}

/**
 * CTRL :
 * BYTE everything else
 */
enum class ReaderEvents {
    BYTE, // everything else
    CTRL, // SOH, EOT, STX, ETX, ACK, NAK
    ESC // ESC = 0x1B
}

enum class ReaderStates {
    START,
    RCVPCKT,
    RCVDATA,
    RCVESC,
    RCVCHK,
    RCVCHKESC,
    CHKSUM,
    END
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="packaged-fsm">Packaged FSM</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class PacketReaderFSM(private val packetHandler: PacketHandler) {
    companion object {

        val definition = stateMachine(
            ReaderStates.values().toSet(),
            ReaderEvents.values().toSet(),
            PacketHandler::class,
            Int::class
        ) {
            defaultInitialState = ReaderStates.START
            default {
                onEvent(ReaderEvents.BYTE to ReaderStates.END) {
                    sendNACK()
                }
                onEvent(ReaderEvents.CTRL to ReaderStates.END) {
                    sendNACK()
                }
                onEvent(ReaderEvents.ESC to ReaderStates.END) {
                    sendNACK()
                }
            }
            whenState(ReaderStates.START) {
                onEvent(
                    ReaderEvents.CTRL to ReaderStates.RCVPCKT,
                    guard = { byte -&gt; byte == CharacterConstants.SOH }) {}
            }
            whenState(ReaderStates.RCVPCKT) {
                onEvent(ReaderEvents.CTRL to ReaderStates.RCVDATA, guard = { byte -&gt; byte == CharacterConstants.STX }) {
                    addField()
                }
                onEvent(ReaderEvents.BYTE to ReaderStates.RCVCHK) { byte -&gt;
                    require(byte != null)
                    addChecksum(byte)
                }
            }
            whenState(ReaderStates.RCVDATA) {
                onEvent(ReaderEvents.BYTE) { byte -&gt;
                    require(byte != null)
                    addByte(byte)
                }
                onEvent(ReaderEvents.CTRL to ReaderStates.RCVPCKT, guard = { byte -&gt; byte == CharacterConstants.ETX }) {
                    endField()
                }
                onEvent(ReaderEvents.ESC to ReaderStates.RCVESC) {}
            }
            whenState(ReaderStates.RCVESC) {
                onEvent(ReaderEvents.ESC to ReaderStates.RCVDATA) {
                    addByte(CharacterConstants.ESC)
                }
                onEvent(ReaderEvents.CTRL to ReaderStates.RCVDATA) { byte -&gt;
                    require(byte != null)
                    addByte(byte)
                }
            }
            whenState(ReaderStates.RCVCHK) {
                onEvent(ReaderEvents.BYTE) { byte -&gt;
                    require(byte != null)
                    addChecksum(byte)
                }
                onEvent(ReaderEvents.ESC to ReaderStates.RCVCHKESC) {}
                onEvent(ReaderEvents.CTRL to ReaderStates.CHKSUM, guard = { byte -&gt; byte == CharacterConstants.EOT }) {
                    checksum()
                }
            }
            whenState(ReaderStates.CHKSUM) {
                automatic(ReaderStates.END, guard = { !checksumValid }) {
                    sendNACK()
                }
                automatic(ReaderStates.END, guard = { checksumValid }) {
                    sendACK()
                }
            }
            whenState(ReaderStates.RCVCHKESC) {
                onEvent(ReaderEvents.ESC to ReaderStates.RCVCHK) {
                    addChecksum(CharacterConstants.ESC)
                }
                onEvent(ReaderEvents.CTRL to ReaderStates.RCVCHK) { byte -&gt;
                    require(byte != null)
                    addChecksum(byte)
                }
            }
        }.build()
    }

    private val fsm = definition.create(packetHandler)
    fun receiveByte(byte: Int) {
        when (byte) {
            CharacterConstants.ESC -&gt; fsm.sendEvent(ReaderEvents.ESC, CharacterConstants.ESC)
            CharacterConstants.SOH,
            CharacterConstants.EOT,
            CharacterConstants.ETX,
            CharacterConstants.STX,
            CharacterConstants.ACK,
            CharacterConstants.NAK -&gt; fsm.sendEvent(ReaderEvents.CTRL, byte)
            else -&gt; fsm.sendEvent(ReaderEvents.BYTE, byte)
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tests">Tests</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class PacketReaderTests {
    @Test
    fun `test reader expect ACK`() {
        val protocolHandler = mockk&lt;ProtocolHandler&gt;()
        every { protocolHandler.sendACK() } just Runs
        val packetReader = Packet(protocolHandler)
        val fsm = PacketReaderFSM(packetReader)
        val stream =
            listOf(
                CharacterConstants.SOH,
                CharacterConstants.STX,
                'A'.toInt(),
                'B'.toInt(),
                'C'.toInt(),
                CharacterConstants.ETX,
                'A'.toInt(),
                CharacterConstants.EOT
            )
        stream.forEach { byte -&gt;
            fsm.receiveByte(byte)
        }
        packetReader.print()
        verify { protocolHandler.sendACK() }
        assertTrue { packetReader.checksumValid }
    }

    @Test
    fun `test reader ESC expect ACK`() {
        val protocolHandler = mockk&lt;ProtocolHandler&gt;()
        every { protocolHandler.sendACK() } just Runs
        val packetReader = Packet(protocolHandler)
        val fsm = PacketReaderFSM(packetReader)
        val stream =
            listOf(
                CharacterConstants.SOH,
                CharacterConstants.STX,
                'A'.toInt(),
                CharacterConstants.ESC,
                CharacterConstants.EOT,
                'C'.toInt(),
                CharacterConstants.ETX,
                'A'.toInt(),
                CharacterConstants.EOT
            )
        stream.forEach { byte -&gt;
            fsm.receiveByte(byte)
        }
        packetReader.print()
        verify { protocolHandler.sendACK() }
        assertTrue { packetReader.checksumValid }
        assertTrue { packetReader.fields.size == 1 }
        assertTrue { packetReader.fields[0].size == 3 }
        assertTrue { packetReader.fields[0][1].toInt() == CharacterConstants.EOT }
    }

    @Test
    fun `test reader ESC expect NACK`() {
        val protocolHandler = mockk&lt;ProtocolHandler&gt;()
        every { protocolHandler.sendNACK() } just Runs
        val packetReader = Packet(protocolHandler)
        val fsm = PacketReaderFSM(packetReader)
        val stream =
            listOf(
                CharacterConstants.SOH,
                CharacterConstants.STX,
                'A'.toInt(),
                CharacterConstants.ESC,
                'C'.toInt(),
                CharacterConstants.ETX,
                'A'.toInt(),
                CharacterConstants.EOT
            )
        stream.forEach { byte -&gt;
            fsm.receiveByte(byte)
        }
        packetReader.print()
        verify { protocolHandler.sendNACK() }
        assertFalse { packetReader.checksumValid }
        assertTrue { packetReader.fields.isEmpty() }
    }

    @Test
    fun `test reader expect NACK`() {
        val protocolHandler = mockk&lt;ProtocolHandler&gt;()
        every { protocolHandler.sendNACK() } just Runs
        val packetReader = Packet(protocolHandler)
        val fsm = PacketReaderFSM(packetReader)
        val stream =
            listOf(
                CharacterConstants.SOH,
                CharacterConstants.STX,
                'A'.toInt(),
                'B'.toInt(),
                'C'.toInt(),
                CharacterConstants.ETX,
                'B'.toInt(),
                CharacterConstants.EOT
            )
        stream.forEach { byte -&gt;
            fsm.receiveByte(byte)
        }
        packetReader.print()
        verify { protocolHandler.sendNACK() }
        assertFalse { packetReader.checksumValid }
    }

    @Test
    fun `test reader multiple fields expect ACK`() {
        val protocolHandler = mockk&lt;ProtocolHandler&gt;()
        every { protocolHandler.sendACK() } just Runs
        val packetReader = Packet(protocolHandler)
        val fsm = PacketReaderFSM(packetReader)
        val stream =
            listOf(
                CharacterConstants.SOH,
                CharacterConstants.STX,
                'A'.toInt(),
                'B'.toInt(),
                'C'.toInt(),
                CharacterConstants.ETX,
                CharacterConstants.STX,
                'D'.toInt(),
                'E'.toInt(),
                'F'.toInt(),
                CharacterConstants.ETX,
                'A'.toInt(),
                'D'.toInt(),
                CharacterConstants.EOT
            )
        stream.forEach { byte -&gt;
            fsm.receiveByte(byte)
        }
        packetReader.print()
        verify { protocolHandler.sendACK() }
        assertTrue { packetReader.checksumValid }
        assertTrue { packetReader.fields.size == 2 }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="immutable-context-example">Immutable Context Example</h3>
<div class="paragraph">
<p>In the case where you want a pure functional context that is immutable the following example will provide what you need:</p>
</div>
<div class="sect3">
<h4 id="immutable-context">Immutable Context</h4>
<div class="paragraph">
<p>The immutable context doesn&#8217;t modify a variable. It returns a copy containing the new context</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">data class ImmutableLock(val locked: Int = 1) {

    fun lock(): ImmutableLock {
        require(locked == 0)
        println("Lock")
        return copy(locked + 1)
    }

    fun doubleLock(): ImmutableLock {
        require(locked == 1)
        println("DoubleLock")
        return copy(locked + 1)
    }

    fun unlock(): ImmutableLock {
        require(locked == 1)
        println("Unlock")
        return copy(locked - 1)
    }

    fun doubleUnlock(): ImmutableLock {
        require(locked == 2)
        println("DoubleUnlock")
        return copy(locked - 1)
    }

    override fun toString(): String {
        return "Lock(locked=$locked)"
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="definition">Definition</h4>
<div class="paragraph">
<p>The definition only exposes one method to handle an event given a context and return the new context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class ImmutableLockFSM() {

    companion object {
        fun handleEvent(context: ImmutableLock, event: LockEvents): ImmutableLock {
            val fsm = definition.create(context)
            return fsm.sendEvent(event, context) ?: error("Expected context not null")
        }

        private val definition = functionalStateMachine(
            LockStates.values().toSet(),
            LockEvents.values().toSet(),
            ImmutableLock::class
        ) {
            defaultInitialState = LockStates.LOCKED
            initialState {
                when (locked) {
                    0 -&gt; LockStates.UNLOCKED
                    1 -&gt; LockStates.LOCKED
                    2 -&gt; LockStates.DOUBLE_LOCKED
                    else -&gt; error("Invalid state locked=$locked")
                }
            }
            default {
                action { state, event, _ -&gt;
                    println("Default action for state($state) -&gt; on($event) for $this")
                    this
                }
                onEntry { startState, targetState, _ -&gt;
                    println("entering:$startState -&gt; $targetState for $this")
                }
                onExit { startState, targetState, _ -&gt;
                    println("exiting:$startState -&gt; $targetState for $this")
                }
            }
            whenState(LockStates.LOCKED) {
                onEvent(LockEvents.LOCK to LockStates.DOUBLE_LOCKED) {
                    doubleLock()
                }
                onEvent(LockEvents.UNLOCK to LockStates.UNLOCKED) {
                    unlock()
                }
            }
            whenState(LockStates.DOUBLE_LOCKED) {
                onEvent(LockEvents.UNLOCK to LockStates.LOCKED) {
                    doubleUnlock()
                }
            }
            whenState(LockStates.UNLOCKED) {
                onEvent(LockEvents.LOCK to LockStates.LOCKED) {
                    lock()
                }
            }
        }.build()
    }
}

operator fun ImmutableLock.plus(event: LockEvents): ImmutableLock {
    return ImmutableLockFSM.handleEvent(this, event)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="usage-2">Usage</h4>
<div class="paragraph">
<p>We also added an overloaded plus operator. The provides for a way of signaling the application of event to context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">        val lock = ImmutableLock(0)
        val locked = lock + LockEvents.LOCK
        assertEquals(locked.locked, 1)
        val doubleLocked = locked + LockEvents.LOCK
        assertEquals(doubleLocked.locked, 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the case where the argument to the state action will be something other than the context you can use a <code>Pair</code> and even when the state is needed separately:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">    val locked = ImmutablePayingTurnstile(50)
    val (state, newTurnStile) = locked + (COIN to 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This assumes the argument is defined as type <code>Int</code> and the return as <code>Pair&lt;LockStates,ImmutablePayingTurnstile&gt;</code>
The <code>handleEventMethod</code> will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">    fun handleEvent(context: ImmutablePayingTurnstile, event: Pair&lt;LockEvents, Int&gt;): Pair&lt;LockStates,ImmutablePayingTurnstile&gt; {
        val fsm = definition.create(context)
        val result = fsm.sendEvent(event.first, event.second) ?: error("Expected context not null")
        return Pair(fsm.currentState, result)
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="further-thoughts">Further thoughts</h3>
<div class="paragraph">
<p>The escape handling from the packet reader could be a separate statemap.
The current implementation has a problem in that the value should be added to different buffer.
It may be worthwhile to have a mechanism for providing a different substate context to take care of this kind of situation.
An interface/class exposed to the substate instead of the full context.
In this example <code>Block</code> will be exposed to the stateMap. The stateMap can then pop after adding the byte.
In the case of an invalid character the statemap will still transition to the end state.</p>
</div>
<div class="paragraph">
<p>The Secure Turnstile is an example of where a timeout would be useful. Allowing override should only be active for a limited period.
This means it could be done by creating a timer that when triggered will cancel the override.
The allow override could also be handled with a statemap which behaves differently but the states in this state map will all have timeouts associated.
The timeout will trigger an optional transition and action.</p>
</div>
<div class="paragraph">
<p>A requirement for timeout handling is correct concurrent handling of events.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started">Getting Started</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="repository">Repository</h3>
<div class="paragraph">
<p>Use this repository for SNAPSHOT builds. Releases are on Maven Central</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url 'https://oss.sonatype.org/content/groups/public'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dependencies">Dependencies</h3>
<div class="sect3">
<h4 id="kotlinjvm-projects">Kotlin/JVM Projects</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'io.jumpco.open:kfsm-jvm:1.0.2'
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kotlinjs-projects">KotlinJS Projects</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'io.jumpco.open:kfsm-js:1.0.2'
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kotlinnative-projects-using-wasm">Kotlin/Native Projects using WASM</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'io.jumpco.open:kfsm-wasm32:1.0.2'
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kotlinnative-projects-using-linuxx64">Kotlin/Native Projects using LinuxX64</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'io.jumpco.open:kfsm-linuxX64:1.0.2'
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kotlinnative-projects-using-mingw64">Kotlin/Native Projects using MinGW64</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'io.jumpco.open:kfsm-mingwX64:1.0.2'
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kotlinnative-projects-using-macos">Kotlin/Native Projects using macOS</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'io.jumpco.open:kfsm-macosX64:1.0.2'
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="operation">Operation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The finite state machine follows a specific set of rules.
This section describes the decision making and order of execution.</p>
</div>
<div class="paragraph">
<p>The state machine will define one or more state maps each representing a subset of possible states of the same type.</p>
</div>
<div class="paragraph">
<p>The state machine will receive events, constrained by set of events. The events no longer have to be an enum class,
only a type with equals and hashCode implementations.</p>
</div>
<div class="paragraph">
<p>The state machine will apply actions to a context. The context represents the work that need to be performed.</p>
</div>
<div class="paragraph">
<p>An event may have arguments.</p>
</div>
<div class="paragraph">
<p>An event may trigger a state transition which defines actions to apply when the state machine is in a specific state.</p>
</div>
<div class="paragraph">
<p>Transitions may have a guard expression that has to evaluate to <code>true</code> to allow execution of transition.</p>
</div>
<div class="paragraph">
<p>Automatic transitions are associated with states and have no events.
Automatic transitions will be executed if the specific state applies after the exit action.</p>
</div>
<div class="paragraph">
<p>The state can be any type, even though we have been using <code>enum class</code> in all samples.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="statemachine-sequence.png" alt="FSM sequence">
</div>
</div>
<div class="paragraph">
<p>When sendEvent is called the state machine applies the event to the current state map.
The current state map is usually top-level state map unless you have defined named maps and used a push transition.</p>
</div>
<div class="sect2">
<h3 id="send-event">Send Event</h3>
<div class="paragraph">
<p>The normal operation is to invoke the following actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>sendEvent</p>
<div class="ulist">
<ul>
<li>
<p>if(external) exitAction</p>
</li>
<li>
<p>action</p>
</li>
<li>
<p>if(external) entryAction</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The exit action is chosen from one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stateMap/whenState/onExit</code></p>
</li>
<li>
<p><code>stateMap/whenState/default/onExit</code></p>
</li>
<li>
<p><code>stateMap/default/onExit</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The action is chosen from one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stateMap/whenState/onEvent</code></p>
</li>
<li>
<p><code>stateMap/whenState/default/action</code></p>
</li>
<li>
<p><code>stateMap/default/action</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The entry action is chosen from one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stateMap/whenState/onEntry</code></p>
</li>
<li>
<p><code>stateMap/whenState/default/onEntry</code></p>
</li>
<li>
<p><code>stateMap/default/onEntry</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The combination of current state and event determines a set of transition rules that have been applied to that combination by one or more definitions.
If the transition rules contains guard transitions the guard expressions are evaluated until one evaluates <code>true</code>.
The <code>onEntry</code> and <code>onExit</code> action are only invoked for <code>external</code> transitions.</p>
</div>
<div class="paragraph">
<p>External transitions have an explicit target state defined. If the target state is not defined it is an internal transition.</p>
</div>
<div class="paragraph">
<p>The currentState determines the exit action. The target state determines the entry action.</p>
</div>
</div>
<div class="sect2">
<h3 id="named-maps-and-push-pop-transitions">Named Maps and Push / Pop Transitions</h3>
<div class="paragraph">
<p>A named map represents a set of states that is grouped together. Named maps can be visited by using a push transition and return using a pop transition.
A push transition requires a map name and a target state along with the normal event and optional guard and action.
The current state map will be pushed on a stack and a statemap instance will be created using the named definition.
Events will be processed according to the transition rules of the named map.</p>
</div>
</div>
<div class="sect2">
<h3 id="life-cycle">Life-cycle</h3>
<div class="paragraph">
<p>The philosophy behind the design is that the finite state machine can be used when needed by creating an instance and providing it with the context.
The state machine can derive the current state from the context or it can be provided with a previously externalised state.
Then events can be sent to the FSM which may trigger actions.
The FSM can also be used to determine which events are allowed for a given state.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dsl">DSL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The DSL provides a way of configuring the statemachine.
The statemachine supports:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transitions: internal and external</p>
</li>
<li>
<p>Guard expressions</p>
</li>
<li>
<p>Entry and exit actions per state and globally</p>
</li>
<li>
<p>Default actions per state and globally</p>
</li>
<li>
<p>Named statemaps</p>
</li>
<li>
<p>Push and pop transitions</p>
</li>
<li>
<p>Automatic transitions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All configuration calls are eventually applied to <a href="javadoc/kfsm/io.jumpco.open.kfsm/-state-machine-builder/index.html">StateMachineBuilder</a></p>
</div>
<div class="sect2">
<h3 id="statemachine"><code>stateMachine</code></h3>
<div class="paragraph">
<p>The top level element is <code>stateMachine</code> either by using the function</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="javadoc/kfsm/io.jumpco.open.kfsm/-state-machine-builder/state-machine.html">StateMachineBuilder::stateMachine</a></p>
</li>
<li>
<p><a href="javadoc/kfsm/io.jumpco.open.kfsm/state-machine.html">stateMachine</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 3 overloaded variations on <code>stateMachine</code> for providing <code>Any</code> as the return type and the argument to events/actions in cases where they are not used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// using global function
val definition = stateMachine(
    State.values().toSet(),
    Event.values().toSet(),
    ContextType::class,
    ArgType::class,
    ReturnType::class
) {
    defaultInitialState = State.S1 // optional start state
    default { // global defaults
    }
    initialState { // initial state expression
    }
    initialStates { // define expression for deriving state stack for nested maps.
    }
    stateMap { // define named statemap
    }
    whenState { // state definition
    }
}.build()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="functionalstatemachine"><code>functionalStateMachine</code></h3>
<div class="paragraph">
<p>The top level element is <code>functionalStateMachine</code> either by using the function</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="javadoc/kfsm/io.jumpco.open.kfsm/functional-state-machine.html">functionalStateMachine</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It provides the same as <code>stateMachine</code> but in this case the Context, argument and return types are all the same.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// using global function
val definition = stateMachine(
    State.values().toSet(),
    Event.values().toSet(),
    ContextType::class
) {
    defaultInitialState = State.S1 // optional start state
    default { // global defaults
    }
    initialState { // initial state expression
    }
    initialStates { // define expression for deriving state stack for nested maps.
    }
    stateMap { // define named statemap
    }
    whenState { // state definition
    }
}.build()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="asyncstatemachine"><code>asyncStateMachine</code></h3>
<div class="paragraph">
<p>This method provides for creating a statemachine definition and instances that have <code>suspend</code> functions as actions.
This also adds the support for <code>timeout</code> on the state map handler.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="javadoc/kfsm/io.jumpco.open.kfsm.async/async-state-machine.html">asyncStateMachine</a></p>
</li>
<li>
<p>link:javadoc/kfsm/io.jumpco.open.kfsm.async/-async-state-machine-builder/state-machine.html</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 3 overloaded variations on <code>stateMachine</code> for providing <code>Any</code> as the return type and the argument to events/actions in cases where they are not used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// using global function
val definition = asyncStateMachine(
    State.values().toSet(),
    Event.values().toSet(),
    ContextType::class,
    ArgType::class,
    ReturnType::class
) {
    defaultInitialState = State.S1 // optional
    default { // global defaults
    }
    initialState { // initial state expression
    }
    initialStates { // define expression for deriving state stack for nested maps.
    }
    stateMap { // define named statemap
    }
    whenState { // state definition
    }
}.build()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="asyncfunctionalstatemachine"><code>asyncFunctionalStateMachine</code></h3>
<div class="paragraph">
<p>This is the same as <code>asyncStateMachine</code> except that Context, argument and return types are all the same.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="javadoc/kfsm/io.jumpco.open.kfsm.async/async-functional-state-machine.html">asyncFunctionalStateMachine</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// using global function
val definition = asyncFunctionalStateMachine(
    State.values().toSet(),
    Event.values().toSet(),
    ContextType::class
) {
    defaultInitialState = State.S1 // optional
    default { // global defaults
    }
    initialState { // initial state expression
    }
    initialStates { // define expression for deriving state stack for nested maps.
    }
    stateMap { // define named statemap
    }
    whenState { // state definition
    }
}.build()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="default"><code>default</code></h3>
<div class="ulist">
<ul>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-machine-handler/default.html">DslStateMachineHandler::default</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Provide default configuration for entry and exit actions as well as a default action.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">default {
    action { // global action
    }
    onEntry { // global state entry action
    }
    onExit { // global state exit action
    }
    onEvent { // default transitions
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="action"><code>action</code></h4>
<div class="ulist">
<ul>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-default-event-handler/action.html">DslStateMachineDefaultEventHandler::action</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Single</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Provide a lambda <code>C.(S, E, A?)&#8594;R?</code> that will be invoked when no other transitions are matched.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">action { currentState, event, arg -&gt; // global default action
    contextFunction()
    anotherContextFunction()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="onentry"><code>onEntry</code></h4>
<div class="ulist">
<ul>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-default-event-handler/on-entry.html">DslStateMachineDefaultEventHandler::onEntry</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Single</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Provide a lambda <code>C.(S,S,A?) &#8594; Unit</code> that will be invoked before a change in the state of the FSM.
Global entry actions will be called for all external transitions after state specific entry actions.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">onEntry { fromState, targetState, arg -&gt;
    entryAction()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="onexit"><code>onExit</code></h4>
<div class="ulist">
<ul>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-default-event-handler/on-exit.html">DslStateMachineDefaultEventHandler::onExit</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Single</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Provide a lambda <code>C.(S,S,A?) &#8594; Unit</code> that will be invoked after a change in the state of the FSM.
Global exit actions will be called for all external transitions after state specific entry actions.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">onExit { fromState, targetState, arg -&gt;
    exitAction()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="onevent"><code>onEvent</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>(event: E [to targetState: S])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-default-event-handler/on-event.html">DslStateMachineDefaultEventHandler::onEvent</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This defines a transition when a specific event is receive and no other transition was matched.
There are 2 variations, the first is internal and doesn&#8217;t define a target state, the second is external and defines a target state.
In both cases the lambda type is <code>C.(A?) &#8594; R?</code></p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">onEvent(Event.EVENT) { arg -&gt; // default internal state action for given event
    someFunction()
}

onEvent(Event.EVENT to State.STATE) { arg -&gt; // default external state action for given event
    anotherFunction()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="initialstate"><code>initialState</code></h3>
<div class="ulist">
<ul>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-machine-handler/initial-state.html">DslStateMachineHandler::initialState</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Single</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Provide a lambda <code>C.() &#8594; S</code> that will determine the state of the state machine.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">initialState {
    when(flag) {
        1 -&gt; State.S1
        2 -&gt; State.S2
        else -&gt; error("Invalid state")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="initialstates"><code>initialStates</code></h3>
<div class="ulist">
<ul>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-machine-handler/initial-states.html">DslStateMachineHandler::initialStates</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Single</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One of <code>initialState</code> or <code>initialStates</code> must be provided.
When a state-machine has named maps the <code>initialStates</code> must be provided.</p>
</div>
<div class="paragraph">
<p>Provide a lambda <code>C.() &#8594; StateMapList&lt;S&gt;</code> that will determine the state of the state machine and map names that should be placed on the stack.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">initialStates {
    mutableListOf&lt;StateMapItem&lt;PayingTurnstileStates&gt;&gt;().apply {
        if (locked) {
            this.add(PayingTurnstileStates.LOCKED to "default")
        } else {
            this.add(PayingTurnstileStates.UNLOCKED to "default")
        }
        if (coins &gt; 0) {
            this.add(PayingTurnstileStates.COINS to "coins")
        }
    }.toMap()
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="whenstate"><code>whenState</code></h3>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>(currentState: S)</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-machine-handler/when-state.html">DslStateMachineHandler::whenState</a></p>
</li>
<li>
<p>Mandatory: <em>Mandatory</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each <code>whenState</code> block decribes the transitions for a given state.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">whenState(State.STATE) {
    default { // default action for State.STATE
    }
    onEntry { // entry action for State.STATE
    }
    onExit { // exit action for State.STATE
    }
    onEvent(Event.EV2 to State.S1, guard = {flag == 1 }) { // external transition with guard expression
    }
    onEventPush(Event.EV2, "mapName", State.S1, gaurd = { flag == 1}) { // push transition to new map with guard expression
    }
    onEventPop(Event.EV3, "newMap", State.S3) { // pop transition leading into new push transition while executing current action only
    }
    automatic(State.S1, guard = { flag == 1}) { // automatic transition to new state when guard is met
    }
    // timeout is limited to AsyncStateMachineBuilder
    timeout(State.S1, timeout, [guard = { expression }]) { // transition to S1 when timeout is triggered and guard is true
    }
    timeoutPop(State.S1, timeout, [guard = { expression }]) { // transition to S1 when timeout is triggered and guard is true
    }
    timeoutPush(State.S1, "mapName",  timeout, [guard = { expression }]) { // transition to S1 when timeout is triggered and guard is true
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="default-2"><code>default</code></h4>
<div class="ulist">
<ul>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-event-handler/default.html">DslStateMachineEventHandler::default</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Single</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A state block may have one default action which is a lambda of type <code>C.(S,E,Array&lt;out Any&gt;) &#8594; Unit</code> that is invoked when no other transition is found for the given state and event and guard expressions.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">default { fromState, event, arg -&gt; // default state action
    someDefaultAction()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="onentry-2"><code>onEntry</code></h4>
<div class="ulist">
<ul>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-event-handler/on-entry.html">DslStateMachineEventHandler::onEntry</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Single</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This defines a lambda of type <code>C.(S,S,A?) &#8594; R?</code> that will be invoked after the transition action for an external transition.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">onEntry { fromState, targetState, arg -&gt; // state entry action
    println("Entering:$targetState from $fromState with $arg")
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="onexit-2"><code>onExit</code></h4>
<div class="ulist">
<ul>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-event-handler/on-exit.html">DslStateMachineEventHandler::onExit</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Single</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This defines a lambda of type <code>C.(S,S,A?) &#8594; Unit</code> that will be invoked before the transition action for an external transitions.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">onExit { fromState, targetState, arg -&gt; // state exit action
    println("Exiting:$fromState to $targetState with $arg")
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="automatic"><code>automatic</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>(targetState: S [, guard:{}])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-event-handler/automatic.html">DslStateMachineDefaultEventHandler::automatic</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 2 variations of automatic transitions: Those with and without guards.
An automatic transition is exercises after the state machine has completed processing a transition.
All automatic transitions attached to a given state will be invoked if their guards are met.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">whenState(State.S1) {
    automatic(State.S1, guard = { flag == 1}) { // automatic transition to new state when guard is met
    }
    automatic(State.S1) { // automatic transition to new state
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="automaticpop"><code>automaticPop</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>([targetMap: String,][,targetState: S] [, guard:{}])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-event-handler/automatic-pop.html">DslStateMachineDefaultEventHandler::automaticPop</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 6 variations of automatic transitions: Those with and without guards, those with and without targetMaps which will lead to a new push transition.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">whenState(State.S1) {
    automaticPop { // pop when S1
    }
    automaticPop(guard= { flag == 1 }) { // pop when S1 and guard is true
    }
    automaticPop(State.S2, guard = { flag == 1 }) { // automatic pop transition to new state when guard is met
    }
    automaticPop(State.S2) { // automatic pop transition to new state
    }
    automaticPop("map1", State.S2) { // automatic pop transition to push transition to new state in target map
    }
    automaticPop("map1", State.S2, guard={flag == 1 }) { // automatic pop transition to push transition to new state in target map
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="automaticpush"><code>automaticPush</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>(targetMap: String, targetState: S [, guard:{}])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-event-handler/automatic-push.html">DslStateMachineDefaultEventHandler::automaticPush</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 2 variations of automatic transitions: Those with and without guards</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">whenState(State.S1) {
    automaticPush("map1", State.S2) { // automatic push transition to S2 in target map "map1"
    }
    automaticPush("map1", State.S2, guard={flag == 1 }) { // automatic push transition to S2 in target map "map1" if guard is true
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="onevent-2"><code>onEvent</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>(event: E [to targetState: S],[guard: {}])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-event-handler/on-event.html">DslStateMachineEventHandler::onEvent</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 4 variations of transitions: External and internal, with and without a guard expression.</p>
</div>
<div class="paragraph">
<p>This defines a transition action for a given event.
For an external transition a target state must be provided, while an internal transition must have no targetState.
An optional guard expression can be provided. The order in which the DSL encounters guard expression determine the evaluation order.
The first matching guard expression will determine the transition that will be used.
Their may be only one transition without a guard expression.</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">onEvent(Event.EV1, guard = { flag == 1 }) { arg -&gt; // internal transition with guard expression
}
onEvent(Event.EV1 to State.S2, guard = { flag == 2}) { arg -&gt; // external transition with guard expression
}
onEvent(Event.EV1) { arg -&gt; // internal transition
}
onEvent(Event.EV2 to State.S2) { arg -&gt; // external transition
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oneventpush"><code>onEventPush</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>(event: E, targetMap: String, targetState: S [, guard:{}])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-event-handler/on-event-push.html">DslStateMachineEventHandler::onEventPush</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 2 variations of automatic transitions: Those with and without guards
Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">whenState(State.S1) {
    onEventPush(Event.EV2, "mapName", State.S2) { // push transition to S2 in new map "mapName"
    }
    onEventPush(Event.EV2, "mapName", State.S2, gaurd = { flag == 1}) { // push transition to S2 in new map "mapName" with guard expression
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oneventpop"><code>onEventPop</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>(event: E [to targetState: S]|[,targetMap: String, targetState: S], [guard:{}])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm/-dsl-state-map-event-handler/on-event-pop.html">DslStateMachineEventHandler::onEventPop</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 6 variations of popTransitions to provide for with and without guards, with and without a new state and with and without a targetMap that will result in a new push transition.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">whenState(State.S1) {
    onEventPop(Event.EV3) { // pop transition without targetState
    }
    onEventPop(Event.EV3, guard={ flag == 1 }) { // pop transition without targetState and guard expression
    }
    onEventPop(Event.EV3 to State.S2) { // pop transition on EV3 changing state to S2
    }
    onEventPop(Event.EV3 to State.S2, guard={ flag == 1 }) { // pop transition on EV3 changing state to S2 with a guard expression
    }
    onEventPop(Event.EV3, "newMap", State.S3) { // pop transition leading into new push transition to S3 in "newMap"
    }
    onEventPop(Event.EV3, "newMap", State.S3, guard={ flag == 1 }) { // pop transition leading into new push transition to S3 in "newMap" with a guard expression
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="timeout"><code>timeout</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>(targetState: S, timeout: Long, [guard:{}])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm.async/-async-dsl-state-map-event-handler/timeout.html">AsyncDslStateMapEventHandler::onEventPop</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 2 versions. One adds the support for a guard expression that will be evaluated and the action will only trigger if the guard evaluates true.</p>
</div>
</div>
<div class="sect3">
<h4 id="timeoutpop"><code>timeoutPop</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>([targetMap: String], targetState: S, timeout: Long, [guard:{}])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm.async/-async-dsl-state-map-event-handler/timeout-pop.html">AsyncDslStateMapEventHandler::timeoutPop</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 5 versions.
Combinations exist to add the optional guard expression and the targetMap.</p>
</div>
</div>
<div class="sect3">
<h4 id="timeoutpush"><code>timeoutPush</code></h4>
<div class="ulist">
<ul>
<li>
<p>Arguments: <code>(targetMap: String, targetState: S, timeout: Long, [guard:{}])</code></p>
</li>
<li>
<p>Handler: <a href="javadoc/kfsm/io.jumpco.open.kfsm.async/-async-dsl-state-map-event-handler/timeout-push.html">AsyncDslStateMapEventHandler::timeoutPush</a></p>
</li>
<li>
<p>Mandatory: <em>Optional</em></p>
</li>
<li>
<p>Cardinality: <em>Multiple</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 2 variations, the 2nd adds the optional guard expression.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0.2<br>
Last updated 2020-03-02 10:24:33 +0200
</div>
</div>
<script src="prism.js"></script>
</body>
</html>